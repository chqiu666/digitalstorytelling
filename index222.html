<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COMPLIANCE PROTOCOL</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', 'OCR-A', monospace;
            cursor: none;
            transition: background-color 0.5s;
        }

        body.pressure-medium { background: #001a00; }
        body.pressure-high { background: #1a1a00; }
        body.pressure-critical { background: #1a0000; }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #video {
            display: none;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: calc(100vw - 350px);
            height: 100vh;
            object-fit: cover;
        }

        #canvas::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 255, 0, 0.03) 0px,
                rgba(0, 255, 0, 0.03) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            animation: scanlines 8s linear infinite;
        }

        @keyframes scanlines {
            0% { transform: translateY(0); }
            100% { transform: translateY(100px); }
        }

        .glitch {
            animation: glitch 0.2s infinite;
        }

        @keyframes glitch {
            0%, 100% { transform: translate(0); filter: hue-rotate(0deg) contrast(1.5); }
            20% { transform: translate(-3px, 2px) skew(0.5deg); filter: hue-rotate(180deg) contrast(2); }
            40% { transform: translate(3px, -3px) skew(-0.5deg); filter: hue-rotate(90deg) contrast(1.8); }
            60% { transform: translate(2px, 3px); filter: hue-rotate(270deg) contrast(2); }
            80% { transform: translate(-2px, -1px) skew(0.3deg); filter: hue-rotate(180deg) contrast(1.5); }
        }

        /* Timer Bar */
        #timerBar {
            position: absolute;
            top: 0;
            left: 0;
            width: calc(100vw - 350px);
            height: 60px;
            background: rgba(0, 0, 0, 0.95);
            border-bottom: 3px solid #ff0000;
            z-index: 1900;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #ff0000;
            letter-spacing: 4px;
            text-shadow: 0 0 15px #ff0000;
            font-weight: bold;
        }

        #timerBar.warning {
            animation: timerPulse 0.5s infinite;
        }

        @keyframes timerPulse {
            0%, 100% { background: rgba(0, 0, 0, 0.95); }
            50% { background: rgba(139, 0, 0, 0.95); }
        }

        /* Behavioral Panel */
        #behavioralPanel {
            position: absolute;
            top: 0;
            right: 0;
            width: 350px;
            height: 100vh;
            background: rgba(0, 0, 0, 0.98);
            border-left: 3px solid #00ff00;
            z-index: 1900;
            overflow-y: auto;
            padding: 20px;
            color: #00ff00;
            font-size: 12px;
        }

        #behavioralPanel h2 {
            font-size: 14px;
            margin-bottom: 15px;
            text-align: center;
            letter-spacing: 2px;
            border-bottom: 2px solid #00ff00;
            padding-bottom: 10px;
        }

        .subject-log {
            margin: 15px 0;
            padding: 12px;
            background: rgba(0, 255, 0, 0.05);
            border: 1px solid #00ff00;
            font-size: 11px;
            line-height: 1.8;
        }

        .subject-state {
            display: inline-block;
            padding: 2px 8px;
            margin-left: 5px;
            font-weight: bold;
        }

        .state-calm { color: #00ff00; }
        .state-curious { color: #00ffff; }
        .state-engaged { color: #00aaff; }
        .state-anxious { color: #ffff00; }
        .state-agitated { color: #ff8800; }
        .state-rebellious { color: #ff0000; text-shadow: 0 0 5px #ff0000; }

        .metric-row {
            margin: 10px 0;
            padding: 8px;
            background: rgba(0, 255, 0, 0.05);
            border: 1px solid #00ff00;
        }

        .metric-label {
            color: #00ff00;
            opacity: 0.7;
            font-size: 10px;
            letter-spacing: 1px;
        }

        .metric-value {
            color: #00ff00;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ff00;
        }

        .status-message {
            margin: 15px 0;
            padding: 10px;
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid #ff0000;
            color: #ff0000;
            text-align: center;
            font-size: 11px;
            letter-spacing: 1px;
            animation: statusBlink 1s infinite;
        }

        @keyframes statusBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Instruction Display */
        #instructionDisplay {
            position: absolute;
            top: 50%;
            left: calc((100vw - 350px) / 2);
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.98);
            border: 4px solid #ff0000;
            padding: 40px 60px;
            z-index: 4000;
            color: #ff0000;
            font-size: 32px;
            text-align: center;
            letter-spacing: 4px;
            text-shadow: 0 0 20px #ff0000;
            box-shadow: 0 0 40px rgba(255, 0, 0, 0.8);
            display: none;
        }

        /* Pop-up Windows */
        .error-popup {
            position: absolute;
            background: #c0c0c0;
            border: 2px outset #fff;
            box-shadow: 3px 3px 0 #000;
            min-width: 300px;
            z-index: 2000;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
            cursor: move;
        }

        .popup-titlebar {
            background: linear-gradient(to right, #000080, #1084d0);
            color: white;
            padding: 3px 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
        }

        .popup-close {
            background: #c0c0c0;
            border: 1px outset #fff;
            width: 16px;
            height: 14px;
            font-size: 10px;
            cursor: pointer;
            text-align: center;
            line-height: 14px;
        }

        .popup-content {
            padding: 20px;
            background: #c0c0c0;
            display: flex;
            align-items: flex-start;
            gap: 15px;
        }

        .popup-icon {
            width: 32px;
            height: 32px;
            font-size: 28px;
        }

        .popup-text {
            flex: 1;
            color: #000;
        }

        .popup-button {
            margin-top: 15px;
            padding: 3px 20px;
            background: #c0c0c0;
            border: 2px outset #fff;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
            cursor: pointer;
        }

        .popup-button:active {
            border-style: inset;
        }

        /* Start Prompt */
        #startPrompt {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #0f0;
            font-size: 20px;
            text-align: center;
            cursor: pointer;
            padding: 30px 50px;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #0f0;
            z-index: 2100;
            text-shadow: 0 0 10px #0f0;
            transition: all 0.3s;
        }

        #startPrompt:hover {
            color: #fff;
            border-color: #0ff;
            text-shadow: 0 0 20px #0ff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        /* End Screen */
        #endScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.98);
            z-index: 2200;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #00ff00;
        }

        #endScreen .stats {
            font-size: 24px;
            line-height: 2.2;
            letter-spacing: 3px;
            text-align: center;
            color: #00aaff;
            text-shadow: 0 0 20px #00aaff;
        }

        /* Interlude Scenes */
        #interludeScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 3000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 2s ease-in-out;
        }

        #interludeScreen.show {
            opacity: 1;
        }

        .interlude-text {
            font-family: 'Helvetica Neue', 'Arial', sans-serif;
            font-size: 48px;
            font-weight: 200;
            line-height: 1.8;
            letter-spacing: 2px;
            text-align: center;
            padding: 0 100px;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff, 0 0 60px #00ffff;
            animation: colorShift 8s ease infinite;
        }

        @keyframes colorShift {
            0% { color: #00ffff; text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff; }
            33% { color: #00ff00; text-shadow: 0 0 20px #00ff00, 0 0 40px #00ff00; }
            66% { color: #0088ff; text-shadow: 0 0 20px #0088ff, 0 0 40px #0088ff; }
            100% { color: #00ffff; text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff; }
        }

        .interlude-text.opening {
            color: #ffffff;
            text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff, 0 0 60px #ffffff;
            animation: openingShift 8s ease infinite;
        }

        @keyframes openingShift {
            0%, 100% { color: #ffffff; text-shadow: 0 0 20px #ffffff, 0 0 40px #00ffff; }
            50% { color: #00ffff; text-shadow: 0 0 20px #00ffff, 0 0 40px #ffffff; }
        }

        .interlude-text.mid-a {
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff, 0 0 40px #ff00ff, 0 0 60px #00ffff;
            animation: midAShift 8s ease infinite;
        }

        @keyframes midAShift {
            0%, 100% { color: #00ffff; text-shadow: 0 0 20px #00ffff, 0 0 40px #ff00ff; }
            50% { color: #ff00ff; text-shadow: 0 0 20px #ff00ff, 0 0 40px #00ffff; }
        }

        .interlude-text.mid-b {
            color: #00ff00;
            text-shadow: 0 0 20px #00ff00, 0 0 40px #0088ff, 0 0 60px #00ffff;
            animation: midBShift 8s ease infinite;
        }

        @keyframes midBShift {
            0% { color: #00ff00; text-shadow: 0 0 20px #00ff00, 0 0 40px #00ff00; }
            50% { color: #0088ff; text-shadow: 0 0 20px #0088ff, 0 0 40px #00ffff; }
            100% { color: #00ff00; text-shadow: 0 0 20px #00ff00, 0 0 40px #00ff00; }
        }

        .interlude-text.ending {
            color: #0088ff;
            text-shadow: 0 0 20px #0088ff, 0 0 40px #ff0000, 0 0 60px #00ffff;
            animation: endingShift 8s ease infinite;
        }

        @keyframes endingShift {
            0% { color: #0088ff; text-shadow: 0 0 20px #0088ff, 0 0 40px #0088ff; }
            50% { color: #ff0000; text-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000; }
            100% { color: #0088ff; text-shadow: 0 0 20px #0088ff, 0 0 40px #00ffff; }
        }
    </style>
</head>
<body>
    <div id="container">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="canvas"></canvas>
        
        <div id="timerBar" style="display: none;">TIMER: 00:00 SEC LEFT</div>
        
        <div id="behavioralPanel" style="display: none;">
            <h2>⚠ LIVE BEHAVIORAL LOG ⚠</h2>
            <div id="metricsContainer"></div>
        </div>
        
        <div id="instructionDisplay"></div>
        
        <div id="startPrompt" style="display: none;">▶ CLICK TO BEGIN PROTOCOL ◀<br><small style="font-size: 12px; opacity: 0.7;">Camera access required</small></div>
        
        <div id="endScreen">
            <div class="stats" id="endStats"></div>
        </div>
        
        <div id="interludeScreen">
            <div class="interlude-text" id="interludeText"></div>
        </div>
    </div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startPrompt = document.getElementById('startPrompt');
        const timerBar = document.getElementById('timerBar');
        const behavioralPanel = document.getElementById('behavioralPanel');
        const instructionDisplay = document.getElementById('instructionDisplay');
        const endScreen = document.getElementById('endScreen');
        const endStats = document.getElementById('endStats');

        let pose;
        let faceMesh;
        let stream = null;
        let isRunning = false;
        let currentPoseData = null;
        let currentFaceData = null;

        // Task system - 15 commands with decreasing durations
        const TASKS = [
            { cmd: 'LOOK AT CAMERA. REMAIN STILL.', duration: 15, check: 'checkStillness' },
            { cmd: 'RAISE YOUR RIGHT HAND.', duration: 14, check: 'checkRightHand' },
            { cmd: 'RAISE YOUR LEFT HAND.', duration: 13, check: 'checkLeftHand' },
            { cmd: 'BLINK THREE TIMES.', duration: 12, check: 'checkBlinks' },
            { cmd: 'SMILE. KEEP SMILING.', duration: 11, check: 'checkSmile' },
            { cmd: 'STEP CLOSER.', duration: 10, check: 'checkCloser' },
            { cmd: 'STEP BACK.', duration: 9, check: 'checkStepBack' },
            { cmd: 'WAVE ONCE.', duration: 8, check: 'checkWaving' },
            { cmd: 'HOLD PERFECTLY STILL. FIVE SECONDS.', duration: 7, check: 'checkFreeze' },
            { cmd: 'TURN AROUND.', duration: 6, check: 'checkTurning' },
            { cmd: 'NOD REPEATEDLY.', duration: 6, check: 'checkNodding' },
            { cmd: 'TILT HEAD LEFT AND RIGHT.', duration: 5, check: 'checkHeadTilt' },
            { cmd: 'JUMP ONCE.', duration: 5, check: 'checkJump' },
            { cmd: 'SHOW BOTH PALMS.', duration: 5, check: 'checkPalms' },
            { cmd: 'FREEZE. AWAIT EVALUATION.', duration: 5, check: 'checkFinalFreeze' }
        ];

        let currentTaskIndex = 0;
        let taskStartTime = null;
        let taskTimeRemaining = 0;
        let failureCount = 0;
        let popups = [];

        // Behavioral metrics per subject
        let subjects = [];
        
        function updateSubjectMetrics(poses) {
            if (!poses || poses.length === 0) return;
            
            // Track first subject
            if (subjects.length === 0) {
                subjects.push({
                    id: 1,
                    movementCount: 0,
                    stillnessFrames: 0,
                    gestureCount: 0,
                    lastPosition: null,
                    recentMovements: [],
                    movementHistory: [], // Track movementCount over time
                    state: 'CALM'
                });
            }
            
            const subject = subjects[0];
            const currentPose = poses[0];
            
            if (!subject.lastPosition) {
                subject.lastPosition = currentPose;
                return;
            }
            
            // Calculate movement
            const movement = calculateMovement(currentPose, subject.lastPosition);
            subject.lastPosition = currentPose;
            
            // Track movement history (last 60 frames = 2 seconds)
            subject.recentMovements.push(movement);
            if (subject.recentMovements.length > 60) {
                subject.recentMovements.shift();
            }
            
            // Update counts - MORE SENSITIVE
            if (movement > 1.5) {
                subject.movementCount++;
                subject.stillnessFrames = 0;
            } else {
                subject.stillnessFrames++;
            }
            
            // Detect gestures (sudden movement spikes)
            if (movement > 10) {
                subject.gestureCount++;
            }
            
            // Track movementCount frequency (every 15 frames = 0.5 second for faster response)
            if (metrics.frameCount % 15 === 0) {
                subject.movementHistory.push(subject.movementCount);
                if (subject.movementHistory.length > 6) { // Keep last 3 seconds
                    subject.movementHistory.shift();
                }
            }
            
            // Determine emotional state - MUCH MORE RESPONSIVE
            if (subject.recentMovements.length >= 15 && subject.movementHistory.length >= 2) {
                const avgMovement = subject.recentMovements.reduce((a, b) => a + b, 0) / subject.recentMovements.length;
                const movementVariance = subject.recentMovements.reduce((sum, m) => sum + Math.pow(m - avgMovement, 2), 0) / subject.recentMovements.length;
                
                // Calculate movement frequency (rate of movement count increase)
                let movementFrequency = 0;
                for (let i = 1; i < subject.movementHistory.length; i++) {
                    movementFrequency += Math.max(0, subject.movementHistory[i] - subject.movementHistory[i-1]);
                }
                movementFrequency /= (subject.movementHistory.length - 1);
                
                // EXTREMELY LOW THRESHOLDS - Very easy to reach REBELLIOUS
                if (avgMovement < 0.2 && movementFrequency < 0.2) {
                    subject.state = 'CALM';
                } else if (movementFrequency >= 0.2 && movementFrequency < 0.5) {
                    // Movement count increasing = curious
                    subject.state = 'CURIOUS';
                } else if (avgMovement >= 0.2 && avgMovement < 0.5 && movementVariance < 1) {
                    subject.state = 'ENGAGED';
                } else if (movementFrequency >= 0.5 || (avgMovement >= 0.5 && avgMovement < 0.8)) {
                    // High frequency or fast movement = anxious
                    subject.state = 'ANXIOUS';
                } else if (avgMovement >= 0.8 || movementVariance > 1.5) {
                    // Very fast movement or erratic = agitated
                    subject.state = 'AGITATED';
                } else {
                    subject.state = 'REBELLIOUS';
                }
            }
        }

        // Global compliance metrics
        let metrics = {
            complianceIndex: 100,
            frameCount: 0
        };

        let lastPosePositions = null;
        let lastBlinkState = 'open';
        let consecutiveSmiles = 0;

        // Continuous popup system
        let popupInterval = null;
        let basePopupDelay = 8000; // Start with 8 seconds between popups
        let protocolStartTime = null;

        // Audio context for beeps
        let audioContext = null;

        function playBeep(frequency = 800, duration = 100) {
            if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.frequency.value = frequency;
            oscillator.type = 'square';
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration / 1000);
        }

        // Canvas sizing
        function resizeCanvas() {
            canvas.width = window.innerWidth - 350;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Initialize MediaPipe detectors
        async function initPoseDetector() {
            pose = new Pose({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
            });
            
            pose.setOptions({
                modelComplexity: 1,
                smoothLandmarks: true,
                enableSegmentation: false,
                smoothSegmentation: false,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            pose.onResults((results) => {
                currentPoseData = results;
            });
        }

        async function initFaceDetector() {
            faceMesh = new FaceMesh({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
            });
            
            faceMesh.setOptions({
                maxNumFaces: 2,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            faceMesh.onResults((results) => {
                currentFaceData = results;
            });
        }

        async function startWebcam() {
            stream = await navigator.mediaDevices.getUserMedia({ 
                video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: 'user' },
                audio: false 
            });
            video.srcObject = stream;
            
            return new Promise((resolve) => {
                video.onloadedmetadata = async () => {
                    await initPoseDetector();
                    await initFaceDetector();
                    resolve();
                };
            });
        }

        function stopWebcam() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
        }

        // Update metrics display
        function updateMetricsDisplay() {
            const container = document.getElementById('metricsContainer');
            
            let subjectsHTML = '';
            subjects.forEach(subject => {
                const stillDuration = Math.floor(subject.stillnessFrames / 30);
                const stateClass = `state-${subject.state.toLowerCase()}`;
                
                subjectsHTML += `
                    <div class="subject-log">
                        <strong>SUBJECT ${String(subject.id).padStart(2, '0')}</strong> | 
                        MOVE: ${subject.movementCount} | 
                        STILL: ${stillDuration}s | 
                        STATE: <span class="subject-state ${stateClass}">${subject.state}</span>
                    </div>
                `;
            });
            
            container.innerHTML = `
                ${subjectsHTML}
                <div class="metric-row">
                    <div class="metric-label">COMPLIANCE INDEX</div>
                    <div class="metric-value">${Math.max(0, Math.floor(metrics.complianceIndex))}%</div>
                </div>
                ${failureCount > 0 ? `
                <div class="status-message">
                    ⚠ FAILURES DETECTED: ${failureCount} ⚠<br>
                    INCREASING SURVEILLANCE
                </div>
                ` : ''}
                <div class="status-message">
                    ${currentTaskIndex < TASKS.length ? 'EVALUATING...' : 'PROCESSING RESULTS...'}
                </div>
            `;
        }

        // Create escalating error popups
        function createEscalatingPopup(failureLevel) {
            playBeep(500 + Math.random() * 400, 200);
            
            const popup = document.createElement('div');
            popup.className = 'error-popup';
            // Keep popups FAR away from center where instructions appear
            // Instructions are at 50% left, so only use far edges
            const leftOrRight = Math.random() > 0.5;
            let xPos, yPos;
            
            if (leftOrRight) {
                // Far left edge only
                xPos = 20 + Math.random() * 100;
            } else {
                // Far right edge only (but not over behavioral panel)
                xPos = window.innerWidth - 350 - 100 - (Math.random() * 100);
            }
            
            // Only top or bottom edges, avoid all middle
            const topOrBottom = Math.random() > 0.5;
            if (topOrBottom) {
                // Top edge only
                yPos = 80 + Math.random() * 100;
            } else {
                // Bottom edge only
                yPos = window.innerHeight - 150 - (Math.random() * 100);
            }
            
            popup.style.left = `${xPos}px`;
            popup.style.top = `${yPos}px`;
            
            // Escalating message stages
            const messagesByStage = [
                // Stage 1 (failures 1-2): Soft
                ['Please cooperate.', 'Task incomplete.', 'Try again.'],
                // Stage 2 (failures 3-4): Irritated
                ['You are wasting time.', 'Compliance required.', 'Stop resisting.'],
                // Stage 3 (failures 5-6): Bossy
                ['Your refusal has been logged.', 'This is being recorded.', 'Insufficient effort.'],
                // Stage 4 (failures 7-9): Hostile
                ['Your footage will be uploaded for public review.', 'COMPLIANCE FAILURE DETECTED.', 'Authority notified. Do better.'],
                // Stage 5 (failures 10+): Overload
                ['WARNING: SUBJECT UNSTABLE', 'ANALYZING BEHAVIORAL DEVIANCE', 'TRY HARDER', 'EVERYONE IS WATCHING', 'ERROR: SUBJECT UNRESPONSIVE', 'Performance inadequate', 'System logging this incident']
            ];
            
            const stageIndex = Math.min(Math.floor(failureLevel / 2), 4);
            const messages = messagesByStage[stageIndex];
            const selectedMessage = messages[Math.floor(Math.random() * messages.length)];
            
            popup.innerHTML = `
                <div class="popup-titlebar">
                    <span>⚠ System Alert</span>
                    <div class="popup-close" onclick="this.parentElement.parentElement.remove()">X</div>
                </div>
                <div class="popup-content">
                    <div class="popup-icon">⚠</div>
                    <div class="popup-text">
                        ${selectedMessage}
                        <div class="popup-button" onclick="this.closest('.error-popup').remove()">OK</div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(popup);
            popups.push(popup);
            
            // Remove after 8 seconds if not clicked
            setTimeout(() => {
                if (popup.parentElement) popup.remove();
            }, 8000);
        }

        // Continuous popup spawning system
        function startContinuousPopups() {
            if (!protocolStartTime) {
                protocolStartTime = Date.now();
            }

            function spawnRandomPopup() {
                if (!isRunning || currentTaskIndex >= TASKS.length) return;

                const elapsed = (Date.now() - protocolStartTime) / 1000;
                const progress = currentTaskIndex / TASKS.length;
                
                // Calculate how many popups to spawn based on time and progress
                let numPopups = 1;
                if (elapsed > 120) { // After 2 minutes
                    numPopups = Math.floor(3 + Math.random() * 4); // 3-6 popups
                } else if (elapsed > 90) { // After 1.5 minutes
                    numPopups = Math.floor(2 + Math.random() * 3); // 2-4 popups
                } else if (elapsed > 60) { // After 1 minute
                    numPopups = Math.floor(1 + Math.random() * 2); // 1-2 popups
                } else if (progress > 0.5) { // After half the tasks
                    numPopups = Math.floor(1 + Math.random() * 2); // 1-2 popups
                }

                // Spawn popups
                for (let i = 0; i < numPopups; i++) {
                    setTimeout(() => {
                        createPressurePopup(progress, elapsed);
                    }, i * 200);
                }

                // Calculate next popup delay (gets faster over time)
                const delayMultiplier = Math.max(0.2, 1 - (elapsed / 180)); // Faster after 3 minutes
                const nextDelay = basePopupDelay * delayMultiplier * (0.7 + Math.random() * 0.6);
                
                popupInterval = setTimeout(spawnRandomPopup, nextDelay);
            }

            // Start the popup loop
            setTimeout(spawnRandomPopup, 5000); // First popup after 5 seconds
        }

        function createPressurePopup(progress, elapsedTime) {
            playBeep(500 + Math.random() * 400, 150);
            
            const popup = document.createElement('div');
            popup.className = 'error-popup';
            // Keep popups away from center where instructions appear
            const leftOrRight = Math.random() > 0.5;
            let xPos, yPos;
            
            if (leftOrRight) {
                // Left side
                xPos = 20 + Math.random() * 200;
            } else {
                // Right side (but not over behavioral panel)
                xPos = window.innerWidth - 420 - (Math.random() * 200);
            }
            
            // Avoid vertical center (40%-60%)
            const topOrBottom = Math.random() > 0.5;
            if (topOrBottom) {
                yPos = 80 + Math.random() * (window.innerHeight * 0.3);
            } else {
                yPos = window.innerHeight * 0.65 + Math.random() * (window.innerHeight * 0.25);
            }
            
            popup.style.left = `${xPos}px`;
            popup.style.top = `${yPos}px`;
            
            // Messages based on progress and time
            const messages = [
                'System monitoring active',
                'Subject behavior logged',
                'Continue compliance protocol',
                'Data transmission in progress',
                'Maintain focus on instructions',
                'Performance being evaluated',
                'Response time recorded',
                'Facial analysis active',
                'Movement patterns tracked',
                'Compliance score updating'
            ];

            if (progress > 0.3) {
                messages.push('Increasing surveillance intensity');
                messages.push('Additional monitoring required');
                messages.push('Subject attention required');
            }

            if (progress > 0.5) {
                messages.push('Critical evaluation phase');
                messages.push('Enhanced tracking enabled');
                messages.push('System demands cooperation');
            }

            if (progress > 0.7) {
                messages.push('FINAL ASSESSMENT ACTIVE');
                messages.push('MAXIMUM SURVEILLANCE');
                messages.push('COMPLY IMMEDIATELY');
                messages.push('TIME RUNNING OUT');
            }

            if (elapsedTime > 90) {
                messages.push('SESSION EXTENDED');
                messages.push('COMPLETE ALL TASKS');
                messages.push('NO EARLY TERMINATION');
            }

            const selectedMessage = messages[Math.floor(Math.random() * messages.length)];
            
            popup.innerHTML = `
                <div class="popup-titlebar">
                    <span>⚠ Surveillance Notice</span>
                    <div class="popup-close" onclick="this.parentElement.parentElement.remove()">X</div>
                </div>
                <div class="popup-content">
                    <div class="popup-icon">👁</div>
                    <div class="popup-text">
                        ${selectedMessage}
                        <div class="popup-button" onclick="this.closest('.error-popup').remove()">OK</div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(popup);
            popups.push(popup);
            
            // Remove after 10 seconds if not clicked
            setTimeout(() => {
                if (popup.parentElement) popup.remove();
            }, 10000);
        }

        // Show interlude screen
        function showInterlude(text, styleClass, duration = 6000) {
            const interludeScreen = document.getElementById('interludeScreen');
            const interludeText = document.getElementById('interludeText');
            
            interludeText.innerHTML = text;
            interludeText.className = `interlude-text ${styleClass}`;
            
            interludeScreen.style.display = 'flex';
            setTimeout(() => {
                interludeScreen.classList.add('show');
            }, 100);
            
            return new Promise(resolve => {
                setTimeout(() => {
                    interludeScreen.classList.remove('show');
                    setTimeout(() => {
                        interludeScreen.style.display = 'none';
                        resolve();
                    }, 2000);
                }, duration);
            });
        }

        // Start new task
        async function startTask() {
            if (currentTaskIndex >= TASKS.length) {
                endProtocol();
                return;
            }
            
            // Show interludes at specific points
            if (currentTaskIndex === 5) {
                await showInterlude('Keep moving.<br>Don\'t stop.<br>Resistance only makes you visible.', 'mid-a');
            } else if (currentTaskIndex === 10) {
                await showInterlude('Do you want freedom,<br>or do you just want to be seen?<br>We keep you safe.<br>You\'re already part of us.', 'mid-b');
            }
            
            const task = TASKS[currentTaskIndex];
            taskStartTime = Date.now();
            taskTimeRemaining = task.duration;
            
            // Show instruction
            instructionDisplay.textContent = task.cmd;
            instructionDisplay.style.display = 'block';
            playBeep(1000, 150);
            
            // Don't hide instruction - it stays until task completes or times out
            
            // Update pressure level
            updatePressureLevel();
        }

        function updatePressureLevel() {
            const progress = currentTaskIndex / TASKS.length;
            document.body.className = '';
            if (progress > 0.7) {
                document.body.className = 'pressure-critical';
            } else if (progress > 0.4) {
                document.body.className = 'pressure-high';
            } else if (progress > 0.2) {
                document.body.className = 'pressure-medium';
            }
        }

        // Update timer
        function updateTimer() {
            if (!taskStartTime) return;
            
            const elapsed = (Date.now() - taskStartTime) / 1000;
            const remaining = Math.max(0, taskTimeRemaining - elapsed);
            
            timerBar.textContent = `TIMER: ${remaining.toFixed(2)} SEC LEFT`;
            
            if (remaining < 5) {
                timerBar.classList.add('warning');
                if (Math.floor(remaining) !== Math.floor(remaining + 0.1)) {
                    playBeep(1200, 50);
                }
            } else {
                timerBar.classList.remove('warning');
            }
            
            if (remaining <= 0) {
                handleTaskTimeout();
            }
        }

        function handleTaskTimeout() {
            // Clear task start time to prevent double-triggering
            taskStartTime = null;
            
            // Hide instruction
            instructionDisplay.style.display = 'none';
            
            console.log(`Task ${currentTaskIndex + 1} timed out. Failure count: ${failureCount + 1}`);
            failureCount++;
            metrics.complianceIndex -= 10;
            
            // Show non-compliance message
            showNonComplianceMessage();
            
            // Spawn escalating popups based on failure count
            const numPopups = Math.min(2 + Math.floor(failureCount * 1.5), 12);
            for (let i = 0; i < numPopups; i++) {
                setTimeout(() => createEscalatingPopup(failureCount), i * 150);
            }
            
            canvas.classList.add('glitch');
            setTimeout(() => canvas.classList.remove('glitch'), 800);
            
            // Move to next task
            const previousTaskIndex = currentTaskIndex;
            currentTaskIndex++;
            
            console.log(`Moving from task ${previousTaskIndex + 1} to task ${currentTaskIndex + 1}. Total tasks: ${TASKS.length}`);
            
            setTimeout(() => {
                // ONLY end if we've gone through ALL 15 tasks
                if (currentTaskIndex >= TASKS.length) {
                    console.log(`All ${TASKS.length} tasks completed. Current index: ${currentTaskIndex}. Ending protocol...`);
                    endProtocol();
                } else {
                    console.log(`Starting task ${currentTaskIndex + 1} of ${TASKS.length}...`);
                    startTask();
                }
            }, 2500);
        }

        function handleTaskSuccess() {
            // Already cleared taskStartTime in the check to prevent double-triggering
            
            // Hide current instruction first
            instructionDisplay.style.display = 'none';
            
            console.log(`Task ${currentTaskIndex + 1} completed successfully!`);
            playBeep(1400, 100);
            metrics.complianceIndex = Math.min(100, metrics.complianceIndex + 5);
            
            // Show brief success indicator
            instructionDisplay.textContent = 'COMPLIANCE CONFIRMED';
            instructionDisplay.style.color = '#00ff00';
            instructionDisplay.style.borderColor = '#00ff00';
            instructionDisplay.style.display = 'block';
            
            // Move to next task
            const previousTaskIndex = currentTaskIndex;
            currentTaskIndex++;
            
            console.log(`Moving from task ${previousTaskIndex + 1} to task ${currentTaskIndex + 1}. Total tasks: ${TASKS.length}`);
            
            setTimeout(() => {
                instructionDisplay.style.display = 'none';
                instructionDisplay.style.color = '#ff0000';
                instructionDisplay.style.borderColor = '#ff0000';
                
                // ONLY end if we've gone through ALL 15 tasks
                if (currentTaskIndex >= TASKS.length) {
                    console.log(`All ${TASKS.length} tasks completed. Current index: ${currentTaskIndex}. Ending protocol...`);
                    endProtocol();
                } else {
                    console.log(`Starting task ${currentTaskIndex + 1} of ${TASKS.length}...`);
                    startTask();
                }
            }, 1500);
        }

        function showNonComplianceMessage() {
            instructionDisplay.textContent = 'NON-COMPLIANCE DETECTED\nPROCEEDING TO NEXT TASK';
            instructionDisplay.style.display = 'block';
            playBeep(400, 300);
            setTimeout(() => {
                instructionDisplay.style.display = 'none';
            }, 2000);
        }

        // Task checking functions
        let stillnessFrames = 0;
        let stillnessBaseline = null;
        const STILLNESS_REQUIRED_FRAMES = 60; // 2 seconds at 30fps

        function checkStillness(poses) {
            if (!poses || poses.length === 0) {
                stillnessFrames = 0;
                stillnessBaseline = null;
                console.log('No pose detected for stillness');
                return false;
            }
            
            // Set baseline on first detection
            if (!stillnessBaseline) {
                stillnessBaseline = poses[0];
                stillnessFrames = 0;
                console.log('Stillness baseline set');
                return false;
            }
            
            const movement = calculateMovement(poses[0], stillnessBaseline);
            
            // If movement is very small, increment stillness counter
            if (movement < 25) { // More forgiving
                stillnessFrames++;
                if (stillnessFrames % 15 === 0) { // Log every 0.5 seconds
                    console.log(`Stillness: ${stillnessFrames}/${STILLNESS_REQUIRED_FRAMES} frames (movement: ${movement.toFixed(2)})`);
                }
            } else {
                console.log(`Too much movement (${movement.toFixed(2)}), resetting stillness`);
                stillnessFrames = 0;
                stillnessBaseline = poses[0]; // Reset baseline
            }
            
            // Pass after being still for required time
            if (stillnessFrames >= STILLNESS_REQUIRED_FRAMES) {
                console.log('✓ Stillness task COMPLETE!');
                stillnessFrames = 0;
                stillnessBaseline = null;
                return true;
            }
            
            return false;
        }

        let rightHandHoldFrames = 0;
        function checkRightHand(poses) {
            if (!poses || poses.length === 0) {
                rightHandHoldFrames = 0;
                return false;
            }
            
            // MediaPipe indices: 16=right wrist, 12=right shoulder
            const rightWrist = poses[0][16];
            const rightShoulder = poses[0][12];
            
            if (!rightWrist || !rightShoulder) {
                rightHandHoldFrames = 0;
                return false;
            }
            
            if (rightWrist.score < 0.2 || rightShoulder.score < 0.2) {
                rightHandHoldFrames = 0;
                return false;
            }
            
            // Hand must be above shoulder
            const handAboveShoulder = rightWrist.y < rightShoulder.y - 0.05;
            
            if (handAboveShoulder) {
                rightHandHoldFrames++;
                if (rightHandHoldFrames % 15 === 0) {
                    console.log(`Right hand UP: ${rightHandHoldFrames}/45 frames`);
                }
                if (rightHandHoldFrames >= 45) {
                    console.log('✓ Right hand COMPLETE!');
                    rightHandHoldFrames = 0;
                    if (subjects.length > 0) subjects[0].gestureCount++;
                    return true;
                }
            } else {
                rightHandHoldFrames = 0;
            }
            return false;
        }

        let leftHandHoldFrames = 0;
        function checkLeftHand(poses) {
            if (!poses || poses.length === 0) {
                leftHandHoldFrames = 0;
                return false;
            }
            
            // MediaPipe indices: 15=left wrist, 11=left shoulder
            const leftWrist = poses[0][15];
            const leftShoulder = poses[0][11];
            
            if (!leftWrist || !leftShoulder) {
                leftHandHoldFrames = 0;
                return false;
            }
            
            if (leftWrist.score < 0.2 || leftShoulder.score < 0.2) {
                leftHandHoldFrames = 0;
                return false;
            }
            
            // Hand must be above shoulder
            const handAboveShoulder = leftWrist.y < leftShoulder.y - 0.05;
            
            if (handAboveShoulder) {
                leftHandHoldFrames++;
                if (leftHandHoldFrames % 15 === 0) {
                    console.log(`Left hand UP: ${leftHandHoldFrames}/45 frames`);
                }
                if (leftHandHoldFrames >= 45) {
                    console.log('✓ Left hand COMPLETE!');
                    leftHandHoldFrames = 0;
                    if (subjects.length > 0) subjects[0].gestureCount++;
                    return true;
                }
            } else {
                leftHandHoldFrames = 0;
            }
            return false;
        }

        let blinkCount = 0;
        let lastEyeState = 'open';
        function checkBlinks(faces) {
            // Detect actual blinks - when eyes close then open
            if (faces && faces.length > 0) {
                // Simplified blink detection based on eye landmarks
                const face = faces[0];
                if (face.keypoints) {
                    // If we can detect face, assume blinking is happening periodically
                    // This is simplified - real blink detection would need eye aspect ratio
                }
            }
            // Pass after waiting most of the time
            if (!blinkResetTime) blinkResetTime = Date.now();
            if (Date.now() - blinkResetTime > 9000) {
                blinkResetTime = 0;
                console.log('Blink task passed (timeout)');
                return true;
            }
            return false;
        }
        let blinkResetTime = 0;

        let smileHoldFrames = 0;
        function checkSmile(faces) {
            // Detect if face is present (simplified smile detection)
            if (faces && faces.length > 0) {
                smileHoldFrames++;
                if (smileHoldFrames % 30 === 0) { // Log every second
                    console.log(`Smile hold frames: ${smileHoldFrames}/120`);
                }
                if (smileHoldFrames >= 120) { // ~4 seconds of face detection
                    smileHoldFrames = 0;
                    console.log('Smile task complete!');
                    return true;
                }
            } else {
                smileHoldFrames = 0;
            }
            return false;
        }

        let initialShoulderAngle = null;
        let turnDetected = false;
        function checkTurning(poses) {
            if (!poses || poses.length === 0) return false;
            
            const leftShoulder = poses[0][5];
            const rightShoulder = poses[0][6];
            
            if (!leftShoulder || !rightShoulder || leftShoulder.score < 0.3 || rightShoulder.score < 0.3) {
                return false;
            }
            
            // Calculate shoulder angle
            const dx = rightShoulder.x - leftShoulder.x;
            const dy = rightShoulder.y - leftShoulder.y;
            const currentAngle = Math.atan2(dy, dx);
            
            if (initialShoulderAngle === null) {
                initialShoulderAngle = currentAngle;
                return false;
            }
            
            // Check if turned significantly (more than 90 degrees / π/2 radians)
            const angleDiff = Math.abs(currentAngle - initialShoulderAngle);
            console.log(`Turn angle difference: ${(angleDiff * 180 / Math.PI).toFixed(1)}°`);
            
            if (angleDiff > Math.PI / 2) {
                initialShoulderAngle = null;
                console.log('Turn detected!');
                return true;
            }
            
            return false;
        }

        let initialBodySize = null;
        let closerHoldFrames = 0;
        function checkCloser(poses) {
            if (!poses || poses.length === 0) return false;
            
            // Calculate body size based on keypoint spread
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            poses[0].forEach(kp => {
                if (kp && kp.score > 0.3) {
                    minX = Math.min(minX, kp.x);
                    maxX = Math.max(maxX, kp.x);
                    minY = Math.min(minY, kp.y);
                    maxY = Math.max(maxY, kp.y);
                }
            });
            
            const bodySize = (maxX - minX) * (maxY - minY);
            
            if (initialBodySize === null) {
                initialBodySize = bodySize;
                return false;
            }
            
            // Check if body appears larger (closer to camera)
            const sizeIncrease = (bodySize - initialBodySize) / initialBodySize;
            console.log(`Body size increase: ${(sizeIncrease * 100).toFixed(1)}%`);
            
            if (sizeIncrease > 0.2) { // 20% larger
                closerHoldFrames++;
                if (closerHoldFrames > 30) { // Hold for 1 second
                    initialBodySize = null;
                    closerHoldFrames = 0;
                    console.log('Closer position detected!');
                    return true;
                }
            } else {
                closerHoldFrames = 0;
            }
            
            return false;
        }

        let backHoldFrames = 0;
        function checkStepBack(poses) {
            if (!poses || poses.length === 0) return false;
            
            // Calculate body size
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            poses[0].forEach(kp => {
                if (kp && kp.score > 0.3) {
                    minX = Math.min(minX, kp.x);
                    maxX = Math.max(maxX, kp.x);
                    minY = Math.min(minY, kp.y);
                    maxY = Math.max(maxY, kp.y);
                }
            });
            
            const bodySize = (maxX - minX) * (maxY - minY);
            
            if (initialBodySize === null) {
                initialBodySize = bodySize;
                return false;
            }
            
            // Check if body appears smaller (further from camera)
            const sizeDecrease = (initialBodySize - bodySize) / initialBodySize;
            console.log(`Body size decrease: ${(sizeDecrease * 100).toFixed(1)}%`);
            
            if (sizeDecrease > 0.15) { // 15% smaller
                backHoldFrames++;
                if (backHoldFrames > 30) { // Hold for 1 second
                    initialBodySize = null;
                    backHoldFrames = 0;
                    console.log('Back position detected!');
                    return true;
                }
            } else {
                backHoldFrames = 0;
            }
            
            return false;
        }

        let waveCount = 0;
        let lastHandHeight = null;
        function checkWaving(poses) {
            if (!poses || poses.length === 0) return false;
            
            const leftWrist = poses[0][9];
            const rightWrist = poses[0][10];
            const nose = poses[0][0];
            
            if (!nose || nose.score < 0.3) return false;
            
            // Check if either hand is above head level and moving
            let handAboveHead = false;
            let currentHandHeight = null;
            
            if (leftWrist && leftWrist.score > 0.3 && leftWrist.y < nose.y) {
                handAboveHead = true;
                currentHandHeight = leftWrist.y;
            } else if (rightWrist && rightWrist.score > 0.3 && rightWrist.y < nose.y) {
                handAboveHead = true;
                currentHandHeight = rightWrist.y;
            }
            
            if (handAboveHead && lastHandHeight !== null) {
                const movement = Math.abs(currentHandHeight - lastHandHeight);
                if (movement > 0.05) { // Significant movement
                    waveCount++;
                    console.log(`Wave movements: ${waveCount}`);
                    if (waveCount > 3) { // Several movements detected
                        waveCount = 0;
                        lastHandHeight = null;
                        console.log('Wave detected!');
                        return true;
                    }
                }
            }
            
            lastHandHeight = currentHandHeight;
            return false;
        }

        let freezeFrames = 0;
        let freezeBaseline = null;
        const FREEZE_REQUIRED_FRAMES = 90; // 3 seconds at 30fps

        function checkFreeze(poses) {
            if (!poses || poses.length === 0) {
                freezeFrames = 0;
                freezeBaseline = null;
                return false;
            }
            
            if (!freezeBaseline) {
                freezeBaseline = poses[0];
                freezeFrames = 0;
                return false;
            }
            
            const movement = calculateMovement(poses[0], freezeBaseline);
            
            if (movement < 20) { // More forgiving threshold
                freezeFrames++;
                if (freezeFrames % 30 === 0) { // Log every second
                    console.log(`Freeze frames: ${freezeFrames}/${FREEZE_REQUIRED_FRAMES} (movement: ${movement.toFixed(2)})`);
                }
            } else {
                console.log(`Movement too much (${movement.toFixed(2)}), resetting freeze counter`);
                freezeFrames = 0;
                freezeBaseline = poses[0];
            }
            
            if (freezeFrames >= FREEZE_REQUIRED_FRAMES) {
                freezeFrames = 0;
                freezeBaseline = null;
                console.log('Freeze task complete!');
                return true;
            }
            
            return false;
        }

        let tiltCount = 0;
        let lastHeadAngle = null;
        function checkHeadTilt(poses) {
            if (!poses || poses.length === 0) return false;
            
            const leftEar = poses[0][3];
            const rightEar = poses[0][4];
            
            if (!leftEar || !rightEar || leftEar.score < 0.3 || rightEar.score < 0.3) {
                // If can't detect ears, check nose position
                const nose = poses[0][0];
                const leftShoulder = poses[0][5];
                const rightShoulder = poses[0][6];
                
                if (nose && leftShoulder && rightShoulder && 
                    nose.score > 0.3 && leftShoulder.score > 0.3 && rightShoulder.score > 0.3) {
                    
                    const shoulderCenterX = (leftShoulder.x + rightShoulder.x) / 2;
                    const headOffset = Math.abs(nose.x - shoulderCenterX);
                    
                    if (lastHeadAngle === null) {
                        lastHeadAngle = headOffset;
                    } else if (Math.abs(headOffset - lastHeadAngle) > 0.1) {
                        tiltCount++;
                        lastHeadAngle = headOffset;
                        console.log(`Head tilt movements: ${tiltCount}`);
                        if (tiltCount >= 2) {
                            tiltCount = 0;
                            lastHeadAngle = null;
                            console.log('Head tilt detected!');
                            return true;
                        }
                    }
                }
                return false;
            }
            
            // Calculate head tilt angle
            const dx = rightEar.x - leftEar.x;
            const dy = rightEar.y - leftEar.y;
            const currentAngle = Math.atan2(dy, dx);
            
            if (lastHeadAngle === null) {
                lastHeadAngle = currentAngle;
                return false;
            }
            
            const angleDiff = Math.abs(currentAngle - lastHeadAngle);
            if (angleDiff > 0.3) { // Significant tilt
                tiltCount++;
                lastHeadAngle = currentAngle;
                console.log(`Head tilt movements: ${tiltCount}`);
                if (tiltCount >= 2) {
                    tiltCount = 0;
                    lastHeadAngle = null;
                    console.log('Head tilt detected!');
                    return true;
                }
            }
            
            return false;
        }

        function checkEyeContact(faces) {
            return faces && faces.length > 0;
        }

        let nodCount = 0;
        let lastNoseY = null;
        function checkNodding(poses) {
            if (!poses || poses.length === 0) return false;
            
            const nose = poses[0][0];
            if (!nose || nose.score < 0.3) return false;
            
            if (lastNoseY === null) {
                lastNoseY = nose.y;
                return false;
            }
            
            const yDiff = Math.abs(nose.y - lastNoseY);
            if (yDiff > 0.03) { // Vertical head movement
                nodCount++;
                lastNoseY = nose.y;
                console.log(`Nod movements: ${nodCount}`);
                if (nodCount >= 5) { // Multiple nods
                    nodCount = 0;
                    lastNoseY = null;
                    console.log('Nodding detected!');
                    return true;
                }
            }
            
            return false;
        }

        let jumpDetected = false;
        let highestHipY = null;
        function checkJump(poses) {
            if (!poses || poses.length === 0) return false;
            
            const leftHip = poses[0][11];
            const rightHip = poses[0][12];
            
            if (!leftHip || !rightHip || leftHip.score < 0.3 || rightHip.score < 0.3) {
                return false;
            }
            
            const avgHipY = (leftHip.y + rightHip.y) / 2;
            
            if (highestHipY === null) {
                highestHipY = avgHipY;
                return false;
            }
            
            // Detect jump (hips go up significantly then come back down)
            if (avgHipY < highestHipY - 0.08) { // Significant upward movement
                console.log('Jump movement detected!');
                jumpDetected = true;
            } else if (jumpDetected && avgHipY > highestHipY - 0.03) { // Back to normal
                highestHipY = null;
                jumpDetected = false;
                console.log('Jump complete!');
                return true;
            }
            
            highestHipY = Math.min(highestHipY, avgHipY);
            return false;
        }

        let palmsHoldFrames = 0;
        function checkPalms(poses) {
            if (!poses || poses.length === 0) {
                palmsHoldFrames = 0;
                return false;
            }
            
            // Check if both hands are visible and extended
            const leftWrist = poses[0][9];
            const rightWrist = poses[0][10];
            const leftElbow = poses[0][7];
            const rightElbow = poses[0][8];
            const leftShoulder = poses[0][5];
            const rightShoulder = poses[0][6];
            
            const leftHandVisible = leftWrist && leftWrist.score > 0.4;
            const rightHandVisible = rightWrist && rightWrist.score > 0.4;
            
            if (!leftHandVisible || !rightHandVisible) {
                palmsHoldFrames = 0;
                return false;
            }
            
            // Check if arms are extended forward (wrists in front of shoulders)
            let armsExtended = false;
            if (leftShoulder && leftShoulder.score > 0.3) {
                armsExtended = leftWrist.y < leftShoulder.y + 0.1;
            }
            if (rightShoulder && rightShoulder.score > 0.3) {
                armsExtended = armsExtended && (rightWrist.y < rightShoulder.y + 0.1);
            }
            
            if (leftHandVisible && rightHandVisible && armsExtended) {
                palmsHoldFrames++;
                console.log(`Both palms visible: ${palmsHoldFrames}/60 frames`);
                if (palmsHoldFrames >= 60) { // Hold for 2 seconds
                    palmsHoldFrames = 0;
                    console.log('Palms detected!');
                    return true;
                }
            } else {
                palmsHoldFrames = 0;
            }
            
            return false;
        }

        let finalFreezeFrames = 0;
        let finalFreezeBaseline = null;
        const FINAL_FREEZE_REQUIRED_FRAMES = 90; // 3 seconds at 30fps

        function checkFinalFreeze(poses) {
            if (!poses || poses.length === 0) {
                finalFreezeFrames = 0;
                finalFreezeBaseline = null;
                return false;
            }
            
            if (!finalFreezeBaseline) {
                finalFreezeBaseline = poses[0];
                finalFreezeFrames = 0;
                return false;
            }
            
            const movement = calculateMovement(poses[0], finalFreezeBaseline);
            
            if (movement < 20) { // More forgiving threshold
                finalFreezeFrames++;
                if (finalFreezeFrames % 30 === 0) { // Log every second
                    console.log(`Final freeze frames: ${finalFreezeFrames}/${FINAL_FREEZE_REQUIRED_FRAMES} (movement: ${movement.toFixed(2)})`);
                }
            } else {
                console.log(`Movement too much (${movement.toFixed(2)}), resetting final freeze counter`);
                finalFreezeFrames = 0;
                finalFreezeBaseline = poses[0];
            }
            
            if (finalFreezeFrames >= FINAL_FREEZE_REQUIRED_FRAMES) {
                finalFreezeFrames = 0;
                finalFreezeBaseline = null;
                console.log('Final freeze task complete!');
                return true;
            }
            
            return false;
        }

        function calculateMovement(pose1, pose2) {
            let totalDiff = 0;
            for (let i = 0; i < pose1.length; i++) {
                if (pose1[i] && pose2[i] && pose1[i].score > 0.3 && pose2[i].score > 0.3) {
                    const dx = pose1[i].x - pose2[i].x;
                    const dy = pose1[i].y - pose2[i].y;
                    totalDiff += Math.sqrt(dx * dx + dy * dy);
                }
            }
            return totalDiff;
        }

        async function endProtocol() {
            isRunning = false;
            
            // Stop continuous popups
            if (popupInterval) {
                clearTimeout(popupInterval);
            }
            
            // Hide all task UI immediately
            timerBar.style.display = 'none';
            behavioralPanel.style.display = 'none';
            canvas.style.display = 'none';
            instructionDisplay.style.display = 'none';
            
            // Stop camera
            stopWebcam();
            
            // Show ending interlude
            await showInterlude('You were never playing a game.<br>You were training the machine.<br>Welcome to the deep surveillance.', 'ending', 8000);
            
            // Prepare end screen content
            const finalScore = Math.max(0, Math.floor(metrics.complianceIndex));
            const successfulTasks = currentTaskIndex - failureCount;
            
            endStats.innerHTML = `
                COMPLIANCE SEQUENCE COMPLETE<br>
                <br>
                DATA ARCHIVED<br>
                <br>
                <div style="font-size: 14px; margin-top: 20px; opacity: 0.7;">
                TASKS PROCESSED: ${TASKS.length}/${TASKS.length}<br>
                SUCCESSFUL: ${successfulTasks}<br>
                FAILURES: ${failureCount}<br>
                FINAL COMPLIANCE INDEX: ${finalScore}%<br>
                </div>
                <br>
                <div style="font-size: 20px; margin-top: 30px;">
                YOU MAY NOW LEAVE
                </div>
            `;
            
            // Show end screen immediately after interlude fades
            endScreen.style.display = 'flex';
            
            // Fade to blue
            document.body.style.transition = 'background-color 2s';
            document.body.style.backgroundColor = '#001a3a';
        }

        // Main processing loop
        async function processFrame() {
            if (!isRunning || !video || video.paused || video.ended) {
                requestAnimationFrame(processFrame);
                return;
            }

            metrics.frameCount++;

            // Send frame to MediaPipe
            if (pose && video.readyState >= 2) {
                await pose.send({image: video});
            }
            if (faceMesh && video.readyState >= 2) {
                await faceMesh.send({image: video});
            }

            // Draw video
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            // Draw MediaPipe results
            if (currentPoseData && currentPoseData.poseLandmarks) {
                drawMediaPipePose(currentPoseData.poseLandmarks);
            }

            if (currentFaceData && currentFaceData.multiFaceLandmarks) {
                currentFaceData.multiFaceLandmarks.forEach(face => {
                    drawMediaPipeFace(face);
                });
            }

            // Debug logging
            if (metrics.frameCount % 60 === 0) {
                const poseDetected = currentPoseData && currentPoseData.poseLandmarks ? 1 : 0;
                const facesDetected = currentFaceData && currentFaceData.multiFaceLandmarks ? currentFaceData.multiFaceLandmarks.length : 0;
                console.log(`Frame ${metrics.frameCount}: Poses=${poseDetected}, Faces=${facesDetected}`);
            }

            // Convert to old format for task checking
            let currentPoses = [];
            let currentFaces = [];
            
            if (currentPoseData && currentPoseData.poseLandmarks) {
                currentPoses = [convertMediaPipePose(currentPoseData.poseLandmarks)];
            }
            
            if (currentFaceData && currentFaceData.multiFaceLandmarks) {
                currentFaces = currentFaceData.multiFaceLandmarks.map(f => ({keypoints: f}));
            }

            // Update subject metrics for behavioral analysis
            if (currentPoses.length > 0) {
                updateSubjectMetrics(currentPoses);
            }

            // Check current task - only if we haven't moved to next task yet
            if (currentTaskIndex < TASKS.length && taskStartTime) {
                const task = TASKS[currentTaskIndex];
                const checker = task.check;
                
                let taskComplete = false;
                if (typeof window[checker] === 'function') {
                    taskComplete = window[checker](currentPoses, currentFaces);
                }
                
                if (taskComplete) {
                    // Prevent double-triggering
                    taskStartTime = null;
                    handleTaskSuccess();
                }
            }

            updateTimer();
            updateMetricsDisplay();

            requestAnimationFrame(processFrame);
        }

        // Convert MediaPipe pose to old format for task checking
        function convertMediaPipePose(landmarks) {
            return landmarks.map(lm => ({
                x: lm.x,
                y: lm.y,
                z: lm.z || 0,
                score: lm.visibility || 1
            }));
        }

        // Draw MediaPipe pose with cyan skeleton
        function drawMediaPipePose(landmarks) {
            const connections = POSE_CONNECTIONS;
            
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 8;

            // Draw connections
            connections.forEach(([i, j]) => {
                const p1 = landmarks[i];
                const p2 = landmarks[j];
                if (p1 && p2) {
                    ctx.beginPath();
                    ctx.moveTo(p1.x * canvas.width, p1.y * canvas.height);
                    ctx.lineTo(p2.x * canvas.width, p2.y * canvas.height);
                    ctx.stroke();
                }
            });
            
            // Draw joints
            ctx.fillStyle = '#00ffff';
            ctx.shadowBlur = 5;
            landmarks.forEach(lm => {
                if (lm) {
                    ctx.beginPath();
                    ctx.arc(lm.x * canvas.width, lm.y * canvas.height, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            ctx.shadowBlur = 0;
            
            // Draw bounding box
            drawMediaPipeBoundingBox(landmarks);
        }

        // MediaPipe pose connections
        const POSE_CONNECTIONS = [
            [11, 12], [11, 13], [13, 15], [12, 14], [14, 16],
            [11, 23], [12, 24], [23, 24],
            [23, 25], [25, 27], [27, 29], [29, 31],
            [24, 26], [26, 28], [28, 30], [30, 32]
        ];

        function drawMediaPipeBoundingBox(landmarks) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            landmarks.forEach(lm => {
                if (lm) {
                    const x = lm.x * canvas.width;
                    const y = lm.y * canvas.height;
                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    maxX = Math.max(maxX, x);
                    maxY = Math.max(maxY, y);
                }
            });

            if (minX === Infinity) return;

            const padding = 30;
            minX -= padding;
            minY -= padding;
            maxX += padding;
            maxY += padding;

            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 10;
            
            const cornerSize = 25;

            // Draw corners
            ctx.beginPath();
            ctx.moveTo(minX, minY + cornerSize);
            ctx.lineTo(minX, minY);
            ctx.lineTo(minX + cornerSize, minY);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(maxX - cornerSize, minY);
            ctx.lineTo(maxX, minY);
            ctx.lineTo(maxX, minY + cornerSize);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(minX, maxY - cornerSize);
            ctx.lineTo(minX, maxY);
            ctx.lineTo(minX + cornerSize, maxY);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(maxX - cornerSize, maxY);
            ctx.lineTo(maxX, maxY);
            ctx.lineTo(maxX, maxY - cornerSize);
            ctx.stroke();

            // Label
            ctx.fillStyle = '#ff0000';
            ctx.font = 'bold 16px monospace';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 12;
            ctx.fillText('SUBJECT 1', minX + 5, minY - 10);
            ctx.shadowBlur = 0;
        }

        // Draw simplified face tracking - just key features
        function drawMediaPipeFace(landmarks) {
            if (!landmarks) return;
            
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#00ff00';
            ctx.shadowBlur = 5;
            
            // Draw face oval
            const faceOval = [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109];
            ctx.beginPath();
            faceOval.forEach((idx, i) => {
                if (landmarks[idx]) {
                    const x = landmarks[idx].x * canvas.width;
                    const y = landmarks[idx].y * canvas.height;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
            });
            ctx.closePath();
            ctx.stroke();
            
            // Draw left eye
            const leftEye = [33, 246, 161, 160, 159, 158, 157, 173, 133, 155, 154, 153, 145, 144, 163, 7];
            ctx.beginPath();
            leftEye.forEach((idx, i) => {
                if (landmarks[idx]) {
                    const x = landmarks[idx].x * canvas.width;
                    const y = landmarks[idx].y * canvas.height;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
            });
            ctx.closePath();
            ctx.stroke();
            
            // Draw right eye
            const rightEye = [362, 398, 384, 385, 386, 387, 388, 466, 263, 249, 390, 373, 374, 380, 381, 382];
            ctx.beginPath();
            rightEye.forEach((idx, i) => {
                if (landmarks[idx]) {
                    const x = landmarks[idx].x * canvas.width;
                    const y = landmarks[idx].y * canvas.height;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
            });
            ctx.closePath();
            ctx.stroke();
            
            // Draw mouth
            const mouth = [61, 185, 40, 39, 37, 0, 267, 269, 270, 409, 291, 375, 321, 405, 314, 17, 84, 181, 91, 146];
            ctx.beginPath();
            mouth.forEach((idx, i) => {
                if (landmarks[idx]) {
                    const x = landmarks[idx].x * canvas.width;
                    const y = landmarks[idx].y * canvas.height;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
            });
            ctx.closePath();
            ctx.stroke();
            
            // Draw nose
            ctx.beginPath();
            if (landmarks[1] && landmarks[4]) {
                ctx.moveTo(landmarks[1].x * canvas.width, landmarks[1].y * canvas.height);
                ctx.lineTo(landmarks[4].x * canvas.width, landmarks[4].y * canvas.height);
                ctx.stroke();
            }
            
            ctx.shadowBlur = 0;
        }

        function drawSkeleton(keypoints) {
            if (!keypoints || keypoints.length === 0) return;
            
            // Pose connections (body skeleton)
            const connections = [
                [5, 6],   // shoulders
                [5, 7],   // left shoulder to elbow
                [7, 9],   // left elbow to wrist
                [6, 8],   // right shoulder to elbow
                [8, 10],  // right elbow to wrist
                [5, 11],  // left shoulder to hip
                [6, 12],  // right shoulder to hip
                [11, 12], // hips
                [11, 13], // left hip to knee
                [13, 15], // left knee to ankle
                [12, 14], // right hip to knee
                [14, 16]  // right knee to ankle
            ];

            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 8;

            connections.forEach(([i, j]) => {
                const kp1 = keypoints[i];
                const kp2 = keypoints[j];
                if (kp1 && kp2 && kp1.score > 0.2 && kp2.score > 0.2) {
                    ctx.beginPath();
                    ctx.moveTo(kp1.x * canvas.width, kp1.y * canvas.height);
                    ctx.lineTo(kp2.x * canvas.width, kp2.y * canvas.height);
                    ctx.stroke();
                }
            });
            
            // Draw joint points
            ctx.fillStyle = '#00ffff';
            ctx.shadowBlur = 5;
            keypoints.forEach((kp, i) => {
                if (kp && kp.score > 0.3) {
                    const x = kp.x * canvas.width;
                    const y = kp.y * canvas.height;
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            ctx.shadowBlur = 0;
        }

        function drawBoundingBox(keypoints, index) {
            if (!keypoints || keypoints.length === 0) return;
            
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            keypoints.forEach(kp => {
                if (kp && kp.score > 0.2) {
                    const x = kp.x * canvas.width;
                    const y = kp.y * canvas.height;
                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    maxX = Math.max(maxX, x);
                    maxY = Math.max(maxY, y);
                }
            });

            if (minX === Infinity) return;

            const padding = 30;
            minX -= padding;
            minY -= padding;
            maxX += padding;
            maxY += padding;

            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 10;
            
            const cornerSize = 25;

            // Top-left corner
            ctx.beginPath();
            ctx.moveTo(minX, minY + cornerSize);
            ctx.lineTo(minX, minY);
            ctx.lineTo(minX + cornerSize, minY);
            ctx.stroke();

            // Top-right corner
            ctx.beginPath();
            ctx.moveTo(maxX - cornerSize, minY);
            ctx.lineTo(maxX, minY);
            ctx.lineTo(maxX, minY + cornerSize);
            ctx.stroke();

            // Bottom-left corner
            ctx.beginPath();
            ctx.moveTo(minX, maxY - cornerSize);
            ctx.lineTo(minX, maxY);
            ctx.lineTo(minX + cornerSize, maxY);
            ctx.stroke();

            // Bottom-right corner
            ctx.beginPath();
            ctx.moveTo(maxX - cornerSize, maxY);
            ctx.lineTo(maxX, maxY);
            ctx.lineTo(maxX, maxY - cornerSize);
            ctx.stroke();

            // Label
            ctx.fillStyle = '#ff0000';
            ctx.font = 'bold 16px monospace';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 12;
            ctx.fillText(`SUBJECT ${index + 1}`, minX + 5, minY - 10);
            ctx.shadowBlur = 0;
        }

        // Show opening poem on page load, then start prompt
        window.addEventListener('load', async () => {
            console.log('=== PAGE LOADED ===');
            console.log('Canvas:', canvas);
            console.log('Video:', video);
            console.log('Context:', ctx);
            
            // Show opening interlude immediately
            await showInterlude('You are in our system.<br>We see you.<br>You move because we say so.', 'opening', 8000);
            
            // Then show start prompt
            startPrompt.style.display = 'block';
        });
        
        // Start the protocol
        startPrompt.addEventListener('click', async () => {
            console.log('=== STARTING PROTOCOL ===');
            startPrompt.textContent = 'INITIALIZING PROTOCOL...';
            try {
                console.log('Starting webcam...');
                await startWebcam();
                console.log('Webcam started successfully');
                console.log('Pose detector:', pose ? 'LOADED' : 'NOT LOADED');
                console.log('Face detector:', faceMesh ? 'LOADED' : 'NOT LOADED');
                
                startPrompt.style.display = 'none';
                isRunning = true;
                
                // Show UI elements
                timerBar.style.display = 'flex';
                behavioralPanel.style.display = 'block';
                canvas.style.display = 'block';
                
                // Start tasks immediately
                setTimeout(() => {
                    console.log('Starting tasks and frame processing...');
                    startTask();
                    startContinuousPopups();
                    processFrame();
                }, 1000);
                
            } catch (err) {
                console.error('CRITICAL ERROR:', err);
                startPrompt.innerHTML = '✖ CAMERA ACCESS DENIED ✖<br><small>Camera permissions required</small>';
                startPrompt.style.color = '#f00';
                startPrompt.style.borderColor = '#f00';
                startPrompt.style.display = 'block';
            }
        });
    </script>
</body>
</html>
